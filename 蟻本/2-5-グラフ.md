# データ構造

p.p.87-106

## 例題 2-5-1　二部グラフ判定

### 二部グラフになるように白黒の塗り分けを行う問題

[AtCoder ABC 126 D - Even Relation](https://atcoder.jp/contests/abc126/tasks/abc126_d)

<details><summary>ソースコード</summary><div>

```C++
signed main()
{
	int N;
	cin >> N;
	vector<vector<pair<int,int>>> side(N);
	int i = N - 1;
	while (i-- > 0) {
		int u, v, w;
		cin >> u >> v >> w;
		side[u-1].emplace_back(make_pair(v-1, w));
		side[v-1].emplace_back(make_pair(u-1, w));
	}

	vector<int> paint(N, 0);
	paint[0] = 1;
	stack<int> st;
	st.push(0);
	while (!st.empty()) {
		int u = st.top();
		st.pop();

		for (auto& v : side[u]) {
			if (paint[v.first] == 0) {
				if (v.second % 2) paint[v.first] = -paint[u];
				else paint[v.first] = paint[u];
				st.push(v.first);
			}
		}
	}

	for (auto& p : paint) {
		if (p > 0) cout << "1\n";
		else cout << "0\n";
	}
	return 0;
}
```

</div></details>

## 例題 2-5-2　Roadblocks (POJ No.3255)

### 純粋な Dijkstra 法

[SoundHound 2018 予選 D - Saving Snuuk](https://atcoder.jp/contests/soundhound2018-summer-qual/tasks/soundhound2018_summer_qual_d)

<details><summary>ソースコード</summary><div>

```C++
template<typename T> std::vector<T> Dijkstra(const T start, const std::vector<std::vector<std::pair<T, T>>>& graph) {
	using namespace std;
	vector<T> mincost(graph.size(), numeric_limits<T>::max()); // i番目のノードまでの最小コスト
	vector<bool> done(graph.size(), false); // i番目のノードまでの最短経路が確定したか
	priority_queue<pair<T, T>, vector<pair<T, T>>, greater<pair<T, T>>> nodes; // 次に最短が確定する候補ノード <コスト，ノード>
	mincost[start] = 0;
	nodes.push(make_pair(0, start));

	// 各ノードまでの最小コストをダイクストラ法で求めていく
	while (!nodes.empty()) {
		pair<T, T> node = nodes.top();
		nodes.pop();

		if (!done[node.second]) {
			done[node.second] = true;
			for (auto& next : graph[node.second]) {
				T cost = node.first + next.first;
				if (mincost[next.second] > cost) {
					mincost[next.second] = cost;
					nodes.push(make_pair(cost, next.second));
				}
			}
		}
	}
	return mincost; // ゴールまでの最小コストを求めるだけならここでreturn
}

signed main()
{
	using LL = long long;
	LL n, m, s, t;
	cin >> n >> m >> s >> t;
	s--; t--;
	vector<vector<pair<LL, LL>>> yen(n), snuuk(n);
	LL i = 0;
	while (i++ < m) {
		LL u, v, a, b;
		cin >> u >> v >> a >> b;
		yen[u - 1].emplace_back(make_pair(a, v - 1));
		yen[v - 1].emplace_back(make_pair(a, u - 1));
		snuuk[u - 1].emplace_back(make_pair(b, v - 1));
		snuuk[v - 1].emplace_back(make_pair(b, u - 1));
	}

	vector<LL> cost_y = Dijkstra(s, yen);
	vector<LL> cost_s = Dijkstra(t, snuuk);

	LL chageCity = n - 1;
	const LL initmoney = static_cast<LL>(1e15);
	vector<pair<LL, LL>> money;
	money.emplace_back(make_pair(initmoney - cost_y[chageCity] - cost_s[chageCity], chageCity));
	chageCity--;
	while (chageCity >= 0) {
		// より早く使えなくなるのに残金が少ない両替所は意味がないので追加しない
		LL mon = initmoney - cost_y[chageCity] - cost_s[chageCity];
		if(mon > money.back().first) money.emplace_back(make_pair(mon, chageCity));
		chageCity--;
	}

	i = 0;
	LL j = money.size() - 1;
	while (i < n) {
		while (money[j].second < i) j--;
		cout << money[j].first << '\n';
		i++;
	}
	return 0;
}
```

</div></details>

## 例題2

### tmp2

[](https)

<details><summary>ソースコード</summary><div>

```C++

```

</div></details>

## 例題3

### tmp3

[](https)

<details><summary>ソースコード</summary><div>

```C++

```

</div></details>
