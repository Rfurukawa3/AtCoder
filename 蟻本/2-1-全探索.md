# 全探索

p.p.30-41

## 例題 2-1-1 部分和問題

### 再帰関数による深さ優先探索

[ABC 045 C たくさんの数式](https://atcoder.jp/contests/abc045/tasks/arc061_a)

<details><summary>ソースコード</summary><div>

```C++
string S;
vector<int> Sint;
long long n, allsum = 0;
void dfs(long long i, long long sum, long long part) {
    if (i == n) {
        allsum += sum + part;
    }
    else {
        // '+'を挿入しない
        dfs(i + 1, sum, part*10 + Sint[i]);

        // '+'を挿入する
        dfs(i + 1, sum + part, Sint[i]);
    }
}

signed main()
{
    cin >> S;
    n = S.size();
    Sint.resize(n);
    for(int i; i < n; i++) {
        Sint[i] = static_cast<long long>(S[i] - '0');
    }

    dfs(1, 0, Sint[0]);

    cout << allsum << endl;
    return 0;
}
```

</div></details>

### スタックを利用した深さ優先探索

[ATC 001 A 深さ優先探索](https://atcoder.jp/contests/atc001/tasks/dfs_a)

<details><summary>ソースコード</summary><div>

```C++
signed main()
{
    int H, W, si, sj;
    const vector<pair<int,int>> mv = { make_pair(-1,0), make_pair(0,-1), make_pair(1,0), make_pair(0,1) };
    cin >> H >> W;
    vector<vector<char>> C(H, vector<char>(W));
    int i = 0, j = 0;
    for(auto& ci : C) {
        j = 0;
        for(auto& cij : ci) {
            cin >> cij;
            if (cij == 's') {
                si = i;
                sj = j;
            }
            j++;
        }
        i++;
    }

    stack<pair<int,int>> st;
    st.push(make_pair(si, sj));
    i = 0, j = 0;
    while (!st.empty()) {
        i = st.top().first;
        j = st.top().second;
        st.pop();
        C[i][j] = '#';
        for(auto& m : mv) {
            int im = i + m.first, jm = j + m.second;
            if (im >= 0 && im < H && jm >= 0 && jm < W) {
                if (C[im][jm] == 'g') {
                    cout << "Yes" << endl;
                    return 0;
                }
                if (C[im][jm] == '.') {
                    st.push(make_pair(im, jm));
                }
            }
        }
    }
    cout << "No" << endl;
    return 0;
}
```

</div></details>

### キューを利用した幅優先探索

[ABC 007 C 幅優先探索](https://atcoder.jp/contests/abc007/tasks/abc007_3)

<details><summary>ソースコード</summary><div>

```C++
signed main()
{
    const vector<pair<int,int>> mv = { make_pair(-1,0), make_pair(0,-1), make_pair(1,0), make_pair(0,1) };
    int R, C, sy, sx, gy, gx;
    cin >> R >> C;
    cin >> sy >> sx;
    cin >> gy >> gx;
    sy--; sx--; gy--; gx--;
    vector<vector<char>> masu(R, vector<char>(C));
    for(auto& my : masu) {
        for(auto& myx : my) {
            cin >> myx;
        }
    }

    vector<vector<int>> distance(R, vector<int>(C, 0));
    distance[sy][sx] = 0;
    queue<pair<int,int>> que;
    masu[sy][sx] = '#';
    que.push(make_pair(sy, sx));

    while (!que.empty()) {
        int y = que.front().first;
        int x = que.front().second;
        int d = distance[y][x] + 1;
        que.pop();

        for(auto& m : mv) {
            int my = y + m.first, mx = x + m.second;
            if (masu[my][mx] == '.') {
                masu[my][mx] = '#';
                que.push(make_pair(my, mx));
                distance[my][mx] = d;
            }
        }
    }
    cout << distance[gy][gx] << endl;
    return 0;
}
```

</div></details>

### next_permutation（順列生成）を利用したn!通りの全探索

[ABC 054 C One-stroke Path](https://atcoder.jp/contests/abc054/tasks/abc054_c)

<details><summary>ソースコード</summary><div>

```C++
signed main()
{
    int N, M;
    cin >> N >> M;
    vector<pair<int,int>> AB(M);
    for(auto& ab : AB) cin >> ab.first >> ab.second;

    vector<int> perm(N-1);
    int i = 2;
    for(auto& p : perm) p = i++; // perm = {2, 3, ... , N}

    i = 2;
    int pattern = 1;
    while (i < N) pattern *= i++;

    // {2, 3, ... , N}の全並べ替えパターンをallpermに格納
    vector<vector<int>> allperm(pattern, vector<int>(N - 1));
    i = 0;
    do {
        allperm[i++] = perm;
    } while (next_permutation(perm.begin(), perm.end()));

    int a, b, cnt = 0;
    bool flg = false, flg2 = false;
    // 全並べ替えパターンについて辺を辿ることができるかを判定
    for(auto& pp : allperm) {
        a = 1; b = 1;
        flg2 = true;
        for(auto& p : pp) {
            a = b;
            b = p;
            flg = false;
            for(auto& ab : AB) {
                // a, bをつなぐ辺があるかの判定
                if ((a == ab.first && b == ab.second) || (b == ab.first && a == ab.second)) {
                    flg = true;
                    break;
                }
            }
            // a, bをつなぐ辺がなければありえないパスなのでbreak
            if (!flg) {
                flg2 = false;
                break;
            }
        }
        // rbf(p, pp)を完走できればあり得るパスなのでカウント追加
        if (flg2) {
            cnt++;
        }
    }

    cout << cnt << endl;
    return 0;
}
```

</div></details>
