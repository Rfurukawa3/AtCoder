# 動的計画法

p.p.52-68

## 例題 2-3-1　01ナップサック問題

### ナップサック問題（例題そのもの）

[AOJ Course 0-1ナップザック問題](http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_1_B&lang=jp)

<details><summary>ソースコード</summary><div>

```C++
signed main()
{
    int N, W;
    cin >> N >> W;
    vector<int> v(N), w(N);
    for(int i=0; i < N; i++) {
        cin >> v[i] >> w[i];
    }

    // dp[i][j] : i番目までの品物から重さjを超えないように選んだときの価値の最大値
    vector<vector<int>> dp(N, vector<int>(W+1, 0));

    // i=0の場合の定義
    for(int j=0; j < W+1; j++) {
        if (w[0] > j) dp[0][j] = 0;
        else dp[0][j] = v[0];
    }

    // i=1以降は漸化式で解く
    for(int i=1; i < N; i++) {
        for(int j=0; j < W + 1; j++) {
            // そもそもi番目の品物が重量オーバーの場合
            if (w[i] > j) dp[i][j] = dp[i - 1][j];

            // i番目の品物を入れない場合と入れる場合とで大きい方を取る
            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]);
        }
    }

    cout << dp[N - 1][W] << endl;
    return 0;
}
```

</div></details>

## 例題 2-3-2　最長共通部分列問題

### 最長共通部分列問題（例題そのもの）

[AOJ Course Longest Common Subsequence](http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_10_C&lang=jp)

<details><summary>ソースコード</summary><div>

```C++
signed main()
{
    int q;
    cin >> q;
    vector<string> X(q), Y(q);
    for(int i=0; i < q; i++) {
        cin >> X[i];
        cin >> Y[i];
    }

    for(int i=0; i < q; i++) {
        int Lx = X[i].size(), Ly = Y[i].size();
        vector<vector<int>> dp(Lx, vector<int>(Ly, 0));

        if (X[i][0] == Y[i][0]) dp[0][0] = 1;
        for(int x=1; x < Lx; x++) {
            if (X[i][x] == Y[i][0]) dp[x][0] = 1;
            else dp[x][0] = dp[x - 1][0];
        }
        for(int y=1; y < Ly; y++) {
            if (X[i][0] == Y[i][y]) dp[0][y] = 1;
            else dp[0][y] = dp[0][y - 1];
        }
        for(int x=1; x < Lx; x++) {
            for(int y=1; y < Ly; y++) {
                if (X[i][x] == Y[i][y]) dp[x][y] = dp[x - 1][y - 1] + 1;
                else dp[x][y] = max(dp[x - 1][y], dp[x][y - 1]);
            }
        }
        cout << dp[Lx - 1][Ly - 1] << endl;
    }

    return 0;
}
```

</div></details>

## 例題 2-3-3　個数制限なしナップサック問題

### ナップザック問題（例題そのもの）

[AOJ Course ナップザック問題](http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_1_C)

<details><summary>ソースコード</summary><div>

```C++
signed main()
{
    int N, W;
    cin >> N >> W;
    vector<int> v(N), w(N);
    for (int i = 0; i < N; i++) {
        cin >> v[i] >> w[i];
    }

    // dp[i+1][j] : i番目までの品物から重さjを超えないように選んだときの価値の最大値
    vector<vector<int>> dp(N + 1, vector<int>(W + 1, 0));

    // 動的計画法
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < W + 1; j++) {
            // そもそもi番目の品物が重量オーバーの場合
            if (w[i] > j) dp[i + 1][j] = dp[i][j];

            // dp[i][j - w[i]]は重さ制限「j - w[i]」の時にi番目の品物を0個以上入れて得た価値
            // 重さ制限がjになった時にi番目の品物を追加するかしないかで比較する
            else dp[i + 1][j] = max(dp[i][j], dp[i + 1][j - w[i]] + v[i]);
        }
    }

    cout << dp[N][W] << endl;
    return 0;
}
```

</div></details>

## 例題 2-3-4　01ナップサック問題その２

### 2種類の01ナップサックDP、半分全列挙の混成

[ABC 032 D ナップサック問題](https://atcoder.jp/contests/abc032/tasks/abc032_d)

<details><summary>ソースコード</summary><div>

```C++
signed main()
{
    using UL = unsigned long;
    using ULL = unsigned long long;
    const ULL INF = UINT64_MAX >> 1;
    UL N, W;
    cin >> N >> W;
    vector<UL> v(N), w(N);
    for (UL i = 0; i < N; i++) cin >> v[i] >> w[i];

    // 半分全列挙
    if (N <= 30uL) {
        // 前半部の全列挙
        UL n = N / 2uL;
        ULL val = 0uLL, weight = 0uLL;
        vector<pair<ULL, ULL>> w_v1;
        w_v1.reserve(1uLL << n);
        for (UL i = 0uL; i < (1uL<<n); i++) {
            bitset<15> sel(i);
            val = 0uLL, weight = 0uLL;
            for (UL j = 0; j < n; j++) {
                val += sel[j] * v[j];
                weight += sel[j] * w[j];
                if (weight > W) break;
            }
            if (weight <= W) w_v1.push_back(make_pair(weight, val));
        }

        // 後半部の全列挙
        UL n0 = N / 2uL;
        n = N - n0;
        val = 0uLL, weight = 0uLL;
        vector<pair<ULL, ULL>> w_v2;
        w_v2.reserve(1uLL << n);
        for (UL i = 0uL; i < (1uL << n); i++) {
            bitset<15> sel(i);
            val = 0uLL, weight = 0uLL;
            for (UL j = 0; j < n; j++) {
                val += sel[j] * v[j + n0];
                weight += sel[j] * w[j + n0];
                if (weight > W) break;
            }
            if (weight <= W) w_v2.push_back(make_pair(weight, val));
        }

        // w_v1の各要素に対して制約を満たしつつ価値を最大化できるw_v2の要素を探す
        ULL ans = 0uLL;
        sort(w_v2.begin(), w_v2.end());
        for (auto& wv : w_v1) {
            ULL lim = W - wv.first;
            auto iter_lim = upper_bound(w_v2.begin(), w_v2.end(), make_pair(lim, INF));
            ULL max2 = 0uLL;
            for (auto iter = w_v2.begin(); iter < iter_lim; iter++) {
                max2 = max(max2, (*iter).second);
            }
            ans = max(ans, wv.second + max2);
        }

        cout << ans << endl;
    }

    // 01ナップサック問題
    else if ((*max_element(w.begin(), w.end())) <= 1000){
        // dp[i+1][j] : i番目までの品物から重さjを超えないように選んだときの価値の最大値
        vector<vector<ULL>> dp(N + 1, vector<ULL>(W + 1, 0));

        // 動的計画法
        for (UL i = 0; i < N; i++) {
            for (UL j = 0; j < W + 1; j++) {
                // そもそもi番目の品物が重量オーバーの場合
                if (w[i] > j) dp[i + 1][j] = dp[i][j];

                // i番目の品物を入れない場合と入れる場合とで大きい方を取る
                else dp[i + 1][j] = max(dp[i][j], dp[i][j - w[i]] + v[i]);
            }
        }

        cout << dp[N][W] << endl;
    }

    // 01ナップサック問題その2
    else {
        // dp[i+1][j] : i番目までの品物から価値がjになるように選んだときの重さの最小値
        UL vsum = accumulate(v.begin(), v.end(), 0uL);
        vector<vector<ULL>> dp(N + 1, vector<ULL>(vsum+1, 0));
        for (UL j = 1; j <= vsum; j++) dp[0][j] = INF; // dp[0][0]=0, dp[0][j]=INF

        // 動的計画法
        for (UL i = 0; i < N; i++) {
            for (UL j = 0; j <= vsum; j++) {
                // そもそもi番目の品物の価値がjより大きい場合
                if (v[i] > j) dp[i + 1][j] = dp[i][j];

                // i番目の品物を入れない場合と入れる場合とで軽い方を取る
                else dp[i + 1][j] = min(dp[i][j], dp[i][j - v[i]] + w[i]);
            }
        }

        UL ans = 0;
        for (UL j = 0; j <= vsum; j++) {
            if (dp[N][j] <= W) ans = j;
        }

        cout << ans << endl;
    }

    return 0;
}
```

</div></details>

## 例題 2-3-5　個数制限付き部分和問題

### DPに残量を持たせることで解く問題

[Maximum-Cup 2018 D Many Go Round](https://atcoder.jp/contests/maximum-cup-2018/tasks/maximum_cup_2018_d)

<details><summary>ソースコード</summary><div>

```C++
signed main()
{
    int N, M, L, X;
    cin >> N >> M >> L >> X;
    vector<int> a(N);
    for (auto& ai : a) cin >> ai;

    int lim = X * M - 1; // 許容される移動量の最大値

    // dp[i+1][j] : i番目までの燃料で停留所jに停まった時の残っている移動可能量、無理な時は-1
    vector<vector<int>> dp(N + 1, vector<int>(M, -1));
    dp[0][0] = X * M - 1;

    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            int t = j - a[i];
            while (t < 0) t += M;

            if (dp[i][j] >= 0) dp[i + 1][j] = dp[i][j];
            else dp[i + 1][j] = dp[i][t] - a[i];

            if (j == L && dp[i + 1][j] >= 0) {
                cout << "Yes\n";
                return 0;
            }
        }
    }
    cout << "No\n";
    return 0;
}
```

## 例題 2-3-6　最長増加部分列問題

## 例題 2-3-7　分割数

## 例題 2-3-8　重複組合せ
