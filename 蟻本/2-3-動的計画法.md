# 動的計画法

p.p.52-68

## 例題 2-3-1　01ナップサック問題

### ナップサック問題（例題そのもの）

[AOJ Course 0-1ナップザック問題](http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_1_B&lang=jp)

<details><summary>ソースコード</summary><div>

```C++
signed main()
{
    int N, W;
    cin >> N >> W;
    vector<int> v(N), w(N);
    for(int i=0; i < N; i++) {
        cin >> v[i] >> w[i];
    }

    // dp[i][j] : i番目までの品物から重さjを超えないように選んだときの価値の最大値
    vector<vector<int>> dp(N, vector<int>(W+1, 0));

    // i=0の場合の定義
    for(int j=0; j < W+1; j++) {
        if (w[0] > j) dp[0][j] = 0;
        else dp[0][j] = v[0];
    }

    // i=1以降は漸化式で解く
    for(int i=1; i < N; i++) {
        for(int j=0; j < W + 1; j++) {
            // そもそもi番目の品物が重量オーバーの場合
            if (w[i] > j) dp[i][j] = dp[i - 1][j];

            // i番目の品物を入れない場合と入れる場合とで大きい方を取る
            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]);
        }
    }

    cout << dp[N - 1][W] << endl;
    return 0;
}
```

</div></details>

## 例題 2-3-2　最長共通部分列問題

### 最長共通部分列問題（例題そのもの）

[AOJ Course Longest Common Subsequence](http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_10_C&lang=jp)

<details><summary>ソースコード</summary><div>

```C++
signed main()
{
    int q;
    cin >> q;
    vector<string> X(q), Y(q);
    for(int i=0; i < q; i++) {
        cin >> X[i];
        cin >> Y[i];
    }

    for(int i=0; i < q; i++) {
        int Lx = X[i].size(), Ly = Y[i].size();
        vector<vector<int>> dp(Lx, vector<int>(Ly, 0));

        if (X[i][0] == Y[i][0]) dp[0][0] = 1;
        for(int x=1; x < Lx; x++) {
            if (X[i][x] == Y[i][0]) dp[x][0] = 1;
            else dp[x][0] = dp[x - 1][0];
        }
        for(int y=1; y < Ly; y++) {
            if (X[i][0] == Y[i][y]) dp[0][y] = 1;
            else dp[0][y] = dp[0][y - 1];
        }
        for(int x=1; x < Lx; x++) {
            for(int y=1; y < Ly; y++) {
                if (X[i][x] == Y[i][y]) dp[x][y] = dp[x - 1][y - 1] + 1;
                else dp[x][y] = max(dp[x - 1][y], dp[x][y - 1]);
            }
        }
        cout << dp[Lx - 1][Ly - 1] << endl;
    }

    return 0;
}
```

</div></details>

## 例題 2-3-3　個数制限なしナップサック問題

## 例題 2-3-4　01ナップサック問題その２

## 例題 2-3-5　個数制限付き部分和問題

## 例題 2-3-6　最長増加部分列問題

## 例題 2-3-7　分割数

## 例題 2-3-8　重複組合せ
